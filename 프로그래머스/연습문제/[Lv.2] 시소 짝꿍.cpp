/* [DP]
 - 배열 DP[] 대신, 'map' 에 저장하는 DP !!! *****
 - 무게x거리 가 같은 짝꿍 쌍 세기 (단, 같은무게가 여러명일 수 있음)**
 - 차례로 weights를 확인하며, 내 앞에 (이미 map에 들어간 원소)중 짝이 있나 확인 후, 
    - 있다면, 확인된 인원만큼(map의 val값 - x중복무게인원 만큼 짝 증가) 더하기
    - 이후, 본인도 map에 추가해 '확인된 인원' 수 늘리기
 
 
 접근법)
 - 거리는 2, 3, 4 => (m1*x1 = m2*x2) 식에서 => x1, x2 사이의 비율은 1, 2/3, 2/4, 3/4 네가지가 될 수 있음
    (더 크게 설정하여 3/2, 2, 4/3 도 있으나, 더 작은 것만으로 추리기)
 - 정렬하여 사용 (더 작은 부분만 확인하기 위해)
 - weights길이가 100,000 으로 1중 for문 O(n) ~ O(nlog n) 내에서 해결해야 함 => (DFS, BFS, 2중 for문 탈락)
 - 중복이 허용되므로, (무게가 같은 사람 여러명 있을 수 있으나, 다 다른사람으로 취급)
    => 각 무게별 인원수도 저장이 가능한 map을 배열 대신 사용 (val, key) = (무게, 인원수)
 
 
 주의사항) 
 - DP에서 if문은 , else if 가 아닌 그냥 if문 써야함 => 모든 경우 check 용
 - 나눗셈)******
    - i*(2/3) => 하면 (2/3)이 int처리로 0취급 되어 올바른 계산 안됨 
    - i*2/3   => 해야 올바른 값 나옴 
    - i*2%3   => 이렇게 나누어 떨어지는지 반드시 확인! (i*2/3 값 자체도 '버림'을 자체수행해 값이 왜곡될 수 있음)
    
 - 만약 같은 무게인 사람이 n명이라면,,,
    1) 본인들끼리 짝 구성 가능 
        - ex_ 100kg짜리가 3명이면, '3C2'로 3중 2명고르는 경우의 수 추가됨
    2) 다른 무게의 짝이 있을 때, 늘어나는 경우의 수 n개씩임 
        - ex_ 100-180 이 짝임을 알았는데 100kg짜리가 3명이라면, 100(1)-180, 100(2)-180, 100(3)-180 으로 세 쌍 추가됨
 - if) 그냥 weights 별로 짝되는 경우의 수 찾으면 => 같은 무게인 사람 고려못해서 => 실패
 - if) input벡터 중, 'find' 함수로 나눠지는 숫자를 찾는다면 => 여러개 중 가장 처음 탐색되는 값만 찾을 수 있음 => 실패
 - if) map을 두종류 만들어, 1- (다른 무게끼리의 짝 종류), 2- (각 무게별 인원수) 세서 곱한 값을 모두 더한다면 
      => 쌍중 한쪽에만 짝 종류 count가 들어가 곱셈 왜곡됨 => 실패                                                   */
#include <string>
#include <vector>
#include <algorithm>
#include <map>
#include <iostream>

using namespace std;

long long solution(vector<int> weights) {
    long long sum =0;
    vector<int> counts={0};
    map<int, int> m;
    
    // 1. 정렬
    sort(weights.begin(), weights.end());
    
    // 2. index 더 작은 것 중, x 2/3, 2/4, 3/4, 1 찾기 
    for(auto w: weights){
        // 1) 2/3 
        if(w*2%3==0 && m.find(w*2/3) !=m.end())
            sum += m[w*2/3];
        // 2) 2/4 
        if(w*2%4==0 && m.find(w*2/4) !=m.end())      
            sum += m[w*2/4];
        // 3) 3/4
        if(w*3%4==0 && m.find(w*3/4) !=m.end())
            sum += m[w*3/4];
        // 4) 1 (같은 수)
        if(m.find(w) !=m.end())
            sum += m[w];
        // 자기자신을 map 에 추가
        m[w]++;
    }
    
    return sum;
}
